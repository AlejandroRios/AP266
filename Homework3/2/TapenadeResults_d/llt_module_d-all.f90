!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7260) - 18 Jan 2019 10:11
!
!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7260) - 18 Jan 2019 10:11
!
MODULE LLT_MODULE_DIFF
  IMPLICIT NONE
  REAL, PARAMETER :: zero=0.0
  REAL, PARAMETER :: pi=3.1415926535897932384626
  REAL, PARAMETER :: eps=EPSILON(zero)

CONTAINS
!  Differentiation of induced_vel in forward (tangent) mode:
!   variations   of useful results: gamma_ind
!   with respect to varying inputs: x x1 x2
  SUBROUTINE INDUCED_VEL_D(uinf, x1, x1d, x2, x2d, x, xd, gamma_ind, &
&   gamma_indd)
    IMPLICIT NONE
! This subroutine computes the velocity induced by
! a horseshoe vortex with kinks at X1 and X2 at the
! point X.
!
! INPUTS
!
! Uinf: real(3) -> Unitary vector along the free-stream direction
! X1: real(3) -> Coordinates of the first kink of the horseshoe vortex
! X2: real(3) -> Coordinates of the second kink of the horseshoe vortex
! X: real(3) -> Coordinates where we want the induced velocity
!
! OUTPUTS
!
! gamma_ind: real(3) -> Aerodynamic influence vector induced
!                       by the horseshoe vortex
    REAL, INTENT(IN) :: uinf(3), x1(3), x2(3), x(3)
    REAL, INTENT(IN) :: x1d(3), x2d(3), xd(3)
    REAL :: r1v(3), r2v(3), r1vr2vcross(3), r1, r2, uinfr1vcross(3), &
&   uinfr2vcross(3), uinfr2vdot, r1vr2vdot, uinfr1vdot, p1(3), p2(3), p3&
&   (3)
    REAL :: r1vd(3), r2vd(3), r1vr2vcrossd(3), r1d, r2d, uinfr1vcrossd(3&
&   ), uinfr2vcrossd(3), uinfr2vdotd, r1vr2vdotd, uinfr1vdotd, p1d(3), &
&   p2d(3), p3d(3)
    REAL, INTENT(OUT) :: gamma_ind(3)
    REAL, INTENT(OUT) :: gamma_indd(3)
    REAL, DIMENSION(3) :: dummyzerodiffd
    REAL, DIMENSION(3) :: dummyzerodiffd0
    REAL, DIMENSION(3) :: dummyzerodiffd1
    REAL, DIMENSION(3) :: dummyzerodiffd2
    r1vd = xd - x1d
    r1v = x - x1
    r2vd = xd - x2d
    r2v = x - x2
    CALL NORM_D(r1v, r1vd, r1, r1d)
! Norm of vector r1v
    CALL NORM_D(r2v, r2vd, r2, r2d)
! Norm of vector r2v
    r1vr2vcrossd = 0.0
    CALL CROSS_D(r1v, r1vd, r2v, r2vd, r1vr2vcross, r1vr2vcrossd)
! Cross product of the vectors r1v and r2v
    uinfr1vcrossd = 0.0
    dummyzerodiffd = 0.0
    CALL CROSS_D(uinf, dummyzerodiffd, r1v, r1vd, uinfr1vcross, &
&          uinfr1vcrossd)
! Cross product of the vectors uinf and r1v
    uinfr2vcrossd = 0.0
    dummyzerodiffd0 = 0.0
    CALL CROSS_D(uinf, dummyzerodiffd0, r2v, r2vd, uinfr2vcross, &
&          uinfr2vcrossd)
! Cross product of the vectors uinf and r2v
    dummyzerodiffd1 = 0.0
    CALL DOT_D(uinf, dummyzerodiffd1, r2v, r2vd, uinfr2vdot, uinfr2vdotd&
&       )
! Dot product of the vectors uinf and r2v
    CALL DOT_D(r1v, r1vd, r2v, r2vd, r1vr2vdot, r1vr2vdotd)
! Dot product of the vectors r1v and r2v
    dummyzerodiffd2 = 0.0
    CALL DOT_D(uinf, dummyzerodiffd2, r1v, r1vd, uinfr1vdot, uinfr1vdotd&
&       )
! Dot product of the vectors uinf and r1v
    p1d = (uinfr2vcrossd*r2*(r2-uinfr2vdot)-uinfr2vcross*(r2d*(r2-&
&     uinfr2vdot)+r2*(r2d-uinfr2vdotd)))/(r2*(r2-uinfr2vdot))**2
    p1 = uinfr2vcross/(r2*(r2-uinfr2vdot))
    p3d = (uinfr1vcrossd*r1*(r1-uinfr1vdot)-uinfr1vcross*(r1d*(r1-&
&     uinfr1vdot)+r1*(r1d-uinfr1vdotd)))/(r1*(r1-uinfr1vdot))**2
    p3 = uinfr1vcross/(r1*(r1-uinfr1vdot))
    IF (r1*r2*(r1*r2+r1vr2vdot) .LT. 1e-2) THEN
      p2 = 0
      p2d = 0.0
    ELSE
      p2d = (((r1d+r2d)*r1vr2vcross+(r1+r2)*r1vr2vcrossd)*r1*r2*(r1*r2+&
&       r1vr2vdot)-(r1+r2)*r1vr2vcross*((r1d*r2+r1*r2d)*(r1*r2+r1vr2vdot&
&       )+r1*r2*(r1d*r2+r1*r2d+r1vr2vdotd)))/(r1*r2*(r1*r2+r1vr2vdot))**&
&       2
      p2 = (r1+r2)*r1vr2vcross/(r1*r2*(r1*r2+r1vr2vdot))
    END IF
    gamma_indd = (p1d+p2d-p3d)/(4*pi)
    gamma_ind = 1/(4*pi)*(p1+p2-p3)
  END SUBROUTINE INDUCED_VEL_D

  SUBROUTINE INDUCED_VEL(uinf, x1, x2, x, gamma_ind)
    IMPLICIT NONE
! This subroutine computes the velocity induced by
! a horseshoe vortex with kinks at X1 and X2 at the
! point X.
!
! INPUTS
!
! Uinf: real(3) -> Unitary vector along the free-stream direction
! X1: real(3) -> Coordinates of the first kink of the horseshoe vortex
! X2: real(3) -> Coordinates of the second kink of the horseshoe vortex
! X: real(3) -> Coordinates where we want the induced velocity
!
! OUTPUTS
!
! gamma_ind: real(3) -> Aerodynamic influence vector induced
!                       by the horseshoe vortex
    REAL, INTENT(IN) :: uinf(3), x1(3), x2(3), x(3)
    REAL :: r1v(3), r2v(3), r1vr2vcross(3), r1, r2, uinfr1vcross(3), &
&   uinfr2vcross(3), uinfr2vdot, r1vr2vdot, uinfr1vdot, p1(3), p2(3), p3&
&   (3)
    REAL, INTENT(OUT) :: gamma_ind(3)
    r1v = x - x1
    r2v = x - x2
    CALL NORM(r1v, r1)
! Norm of vector r1v
    CALL NORM(r2v, r2)
! Norm of vector r2v
    CALL CROSS(r1v, r2v, r1vr2vcross)
! Cross product of the vectors r1v and r2v
    CALL CROSS(uinf, r1v, uinfr1vcross)
! Cross product of the vectors uinf and r1v
    CALL CROSS(uinf, r2v, uinfr2vcross)
! Cross product of the vectors uinf and r2v
    CALL DOT(uinf, r2v, uinfr2vdot)
! Dot product of the vectors uinf and r2v
    CALL DOT(r1v, r2v, r1vr2vdot)
! Dot product of the vectors r1v and r2v
    CALL DOT(uinf, r1v, uinfr1vdot)
! Dot product of the vectors uinf and r1v
    p1 = uinfr2vcross/(r2*(r2-uinfr2vdot))
    p3 = uinfr1vcross/(r1*(r1-uinfr1vdot))
    IF (r1*r2*(r1*r2+r1vr2vdot) .LT. 1e-2) THEN
      p2 = 0
    ELSE
      p2 = (r1+r2)*r1vr2vcross/(r1*r2*(r1*r2+r1vr2vdot))
    END IF
    gamma_ind = 1/(4*pi)*(p1+p2-p3)
  END SUBROUTINE INDUCED_VEL

!  Differentiation of get_aic_matrix in forward (tangent) mode:
!   variations   of useful results: aic
!   with respect to varying inputs: x
!============================================================
  SUBROUTINE GET_AIC_MATRIX_D(nv, x, xd, uinf, aic, aicd)
    IMPLICIT NONE
! This subroutine computes the Aerodynamic Influence Coefficients (AIC)
! matrix that gives the adimensionalized induced velocities in
! all bound segments in X, that is: Vind = AIC*Gamma.
! Vind(1:3,ii) = AIC(1:3,:,ii)*Gamma(:)
! INPUTS
! n_vort: integer -> Number of horseshoe vortices.
! X: real(3,n_vort+1) -> Coordinates of the kinks of the horseshoe vortices.
! Uinf: real(3) -> Unitary vector along the free-stream direction.
! OUTPUTS
! AIC: real(3,n_vort,n_vort) -> Aerodynamic Influence matrix.
    INTEGER, INTENT(IN) :: nv
    INTEGER :: ii, jj
    REAL :: x1ii(3), x2ii(3), x1jj(3), x2jj(3), xc(3), gamma_ind(3)
    REAL :: x1iid(3), x2iid(3), x1jjd(3), x2jjd(3), xcd(3), gamma_indd(3&
&   )
    REAL, INTENT(IN) :: x(3, nv+1), uinf(3)
    REAL, INTENT(IN) :: xd(3, nv+1)
    REAL, INTENT(OUT) :: aic(3, nv, nv)
    REAL, INTENT(OUT) :: aicd(3, nv, nv)
    aicd = 0.0
    DO ii=1,nv
      x1iid = xd(:, ii)
      x1ii = x(:, ii)
      x2iid = xd(:, ii+1)
      x2ii = x(:, ii+1)
      xcd = (x1iid+x2iid)/2
      xc = (x1ii+x2ii)/2
      DO jj=1,nv
        x1jjd = xd(:, jj)
        x1jj = x(:, jj)
        x2jjd = xd(:, jj+1)
        x2jj = x(:, jj+1)
        CALL INDUCED_VEL_D(uinf, x1jj, x1jjd, x2jj, x2jjd, xc, xcd, &
&                    gamma_ind, gamma_indd)
        aicd(:, jj, ii) = gamma_indd
        aic(:, jj, ii) = gamma_ind
      END DO
    END DO
  END SUBROUTINE GET_AIC_MATRIX_D

!============================================================
  SUBROUTINE GET_AIC_MATRIX(nv, x, uinf, aic)
    IMPLICIT NONE
! This subroutine computes the Aerodynamic Influence Coefficients (AIC)
! matrix that gives the adimensionalized induced velocities in
! all bound segments in X, that is: Vind = AIC*Gamma.
! Vind(1:3,ii) = AIC(1:3,:,ii)*Gamma(:)
! INPUTS
! n_vort: integer -> Number of horseshoe vortices.
! X: real(3,n_vort+1) -> Coordinates of the kinks of the horseshoe vortices.
! Uinf: real(3) -> Unitary vector along the free-stream direction.
! OUTPUTS
! AIC: real(3,n_vort,n_vort) -> Aerodynamic Influence matrix.
    INTEGER, INTENT(IN) :: nv
    INTEGER :: ii, jj
    REAL :: x1ii(3), x2ii(3), x1jj(3), x2jj(3), xc(3), gamma_ind(3)
    REAL, INTENT(IN) :: x(3, nv+1), uinf(3)
    REAL, INTENT(OUT) :: aic(3, nv, nv)
    DO ii=1,nv
      x1ii = x(:, ii)
      x2ii = x(:, ii+1)
      xc = (x1ii+x2ii)/2
      DO jj=1,nv
        x1jj = x(:, jj)
        x2jj = x(:, jj+1)
        CALL INDUCED_VEL(uinf, x1jj, x2jj, xc, gamma_ind)
        aic(:, jj, ii) = gamma_ind
      END DO
    END DO
  END SUBROUTINE GET_AIC_MATRIX

!  Differentiation of get_geom_vectors in forward (tangent) mode:
!   variations   of useful results: uai uni si areas
!   with respect to varying inputs: chords alpha0 x
!============================================================
  SUBROUTINE GET_GEOM_VECTORS_D(n_vort, x, xd, alpha0, alpha0d, chords, &
&   chordsd, uai, uaid, uni, unid, si, sid, areas, areasd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL, INTENT(IN) :: xd(3, n_vort+1)
    REAL, INTENT(IN) :: alpha0(n_vort), chords(n_vort)
    REAL, INTENT(IN) :: alpha0d(n_vort), chordsd(n_vort)
! Output variables
    REAL, INTENT(OUT) :: uai(3, n_vort), uni(3, n_vort)
    REAL, INTENT(OUT) :: uaid(3, n_vort), unid(3, n_vort)
    REAL, INTENT(OUT) :: si(3, n_vort), areas(n_vort)
    REAL, INTENT(OUT) :: sid(3, n_vort), areasd(n_vort)
! Working variables
    INTEGER :: ii
    REAL :: x1(3), x2(3), usi(3), ni(3)
    REAL :: x1d(3), x2d(3), usid(3), nid(3)
    REAL :: nim, sim
    REAL :: nimd, simd
    INTRINSIC COS
    INTRINSIC SIN
    uaid = 0.0
    unid = 0.0
    sid = 0.0
    areasd = 0.0
    nid = 0.0
! EXECUTION
! Loop over all vortices
    DO ii=1,n_vort
! Get kink coordinates of the current vortex
      x1d = xd(:, ii)
      x1 = x(:, ii)
      x2d = xd(:, ii+1)
      x2 = x(:, ii+1)
! Compute the vector along the local span
      sid(:, ii) = x2d - x1d
      si(:, ii) = x2 - x1
      CALL NORMALIZE_D(si(:, ii), sid(:, ii), usi, usid)
! Create a unitary vector along the chordline
! pointing to the trailing edge
      uaid(1, ii) = -(alpha0d(ii)*SIN(alpha0(ii)))
      uai(1, ii) = COS(alpha0(ii))
      uaid(2, ii) = 0.0
      uai(2, ii) = zero
      uaid(3, ii) = -(alpha0d(ii)*COS(alpha0(ii)))
      uai(3, ii) = -SIN(alpha0(ii))
! Get the normal vector as the normal between the span
! and the chord vector
      CALL CROSS_D(uai(:, ii), uaid(:, ii), usi, usid, ni, nid)
      CALL NORMALIZE_D(ni, nid, uni(:, ii), unid(:, ii))
! Compute the local area of the panel.
! The norm of the normal vector is the sine of the angle.
      CALL NORM_D(ni, nid, nim, nimd)
      CALL NORM_D(si(:, ii), sid(:, ii), sim, simd)
      areasd(ii) = (nimd*sim+nim*simd)*chords(ii) + nim*sim*chordsd(ii)
      areas(ii) = nim*chords(ii)*sim
    END DO
  END SUBROUTINE GET_GEOM_VECTORS_D

!============================================================
  SUBROUTINE GET_GEOM_VECTORS(n_vort, x, alpha0, chords, uai, uni, si, &
&   areas)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL, INTENT(IN) :: alpha0(n_vort), chords(n_vort)
! Output variables
    REAL, INTENT(OUT) :: uai(3, n_vort), uni(3, n_vort)
    REAL, INTENT(OUT) :: si(3, n_vort), areas(n_vort)
! Working variables
    INTEGER :: ii
    REAL :: x1(3), x2(3), usi(3), ni(3)
    REAL :: nim, sim
    INTRINSIC COS
    INTRINSIC SIN
! EXECUTION
! Loop over all vortices
    DO ii=1,n_vort
! Get kink coordinates of the current vortex
      x1 = x(:, ii)
      x2 = x(:, ii+1)
! Compute the vector along the local span
      si(:, ii) = x2 - x1
      CALL NORMALIZE(si(:, ii), usi)
! Create a unitary vector along the chordline
! pointing to the trailing edge
      uai(1, ii) = COS(alpha0(ii))
      uai(2, ii) = zero
      uai(3, ii) = -SIN(alpha0(ii))
! Get the normal vector as the normal between the span
! and the chord vector
      CALL CROSS(uai(:, ii), usi, ni)
      CALL NORMALIZE(ni, uni(:, ii))
! Compute the local area of the panel.
! The norm of the normal vector is the sine of the angle.
      CALL NORM(ni, nim)
      CALL NORM(si(:, ii), sim)
      areas(ii) = nim*chords(ii)*sim
    END DO
  END SUBROUTINE GET_GEOM_VECTORS

!  Differentiation of get_local_vels in forward (tangent) mode:
!   variations   of useful results: vlocal alphalocal
!   with respect to varying inputs: uai uni gama aic
!============================================================
  SUBROUTINE GET_LOCAL_VELS_D(n_vort, gama, gamad, aic, aicd, vinf, uai&
&   , uaid, uni, unid, vlocal, vlocald, alphalocal, alphalocald)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: gama(n_vort), aic(3, n_vort, n_vort)
    REAL, INTENT(IN) :: gamad(n_vort), aicd(3, n_vort, n_vort)
    REAL, INTENT(IN) :: vinf(3), uai(3, n_vort), uni(3, n_vort)
    REAL, INTENT(IN) :: uaid(3, n_vort), unid(3, n_vort)
! Output variables
    REAL, INTENT(OUT) :: vlocal(3, n_vort), alphalocal(n_vort)
    REAL, INTENT(OUT) :: vlocald(3, n_vort), alphalocald(n_vort)
! Working variables
    INTEGER :: ii, jj
    REAL :: num, den
    REAL :: numd, dend
    INTRINSIC ATAN
    vlocald = 0.0
    alphalocald = 0.0
! EXECUTION
! Do the matrix operation
    DO ii=1,n_vort
! Start with the free-strem contribution
      vlocald(:, ii) = 0.0
      vlocal(:, ii) = vinf
! Now add the velocities induced by each vortex
      DO jj=1,n_vort
        vlocald(:, ii) = vlocald(:, ii) + aicd(:, jj, ii)*gama(jj) + aic&
&         (:, jj, ii)*gamad(jj)
        vlocal(:, ii) = vlocal(:, ii) + aic(:, jj, ii)*gama(jj)
      END DO
! Compute the local angle of attack
      CALL DOT_D(vlocal(:, ii), vlocald(:, ii), uni(:, ii), unid(:, ii)&
&          , num, numd)
      CALL DOT_D(vlocal(:, ii), vlocald(:, ii), uai(:, ii), uaid(:, ii)&
&          , den, dend)
      alphalocald(ii) = (numd*den-num*dend)/(den**2*(1.0+(num/den)**2))
      alphalocal(ii) = ATAN(num/den)
    END DO
  END SUBROUTINE GET_LOCAL_VELS_D

!============================================================
  SUBROUTINE GET_LOCAL_VELS(n_vort, gama, aic, vinf, uai, uni, vlocal, &
&   alphalocal)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: gama(n_vort), aic(3, n_vort, n_vort)
    REAL, INTENT(IN) :: vinf(3), uai(3, n_vort), uni(3, n_vort)
! Output variables
    REAL, INTENT(OUT) :: vlocal(3, n_vort), alphalocal(n_vort)
! Working variables
    INTEGER :: ii, jj
    REAL :: num, den
    INTRINSIC ATAN
! EXECUTION
! Do the matrix operation
    DO ii=1,n_vort
! Start with the free-strem contribution
      vlocal(:, ii) = vinf
! Now add the velocities induced by each vortex
      DO jj=1,n_vort
        vlocal(:, ii) = vlocal(:, ii) + aic(:, jj, ii)*gama(jj)
      END DO
! Compute the local angle of attack
      CALL DOT(vlocal(:, ii), uni(:, ii), num)
      CALL DOT(vlocal(:, ii), uai(:, ii), den)
      alphalocal(ii) = ATAN(num/den)
    END DO
  END SUBROUTINE GET_LOCAL_VELS

!  Differentiation of compute_circulation_forces in forward (tangent) mode:
!   variations   of useful results: fcirc
!   with respect to varying inputs: vlocal gama si
!============================================================
  SUBROUTINE COMPUTE_CIRCULATION_FORCES_D(n_vort, rho, vlocal, vlocald, &
&   si, sid, gama, gamad, fcirc, fcircd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: rho, vlocal(3, n_vort), si(3, n_vort)
    REAL, INTENT(IN) :: vlocald(3, n_vort), sid(3, n_vort)
    REAL, INTENT(IN) :: gama(n_vort)
    REAL, INTENT(IN) :: gamad(n_vort)
! Output variables
    REAL, INTENT(OUT) :: fcirc(3, n_vort)
    REAL, INTENT(OUT) :: fcircd(3, n_vort)
! Working variables
    INTEGER :: ii
    REAL :: li(3)
    REAL :: lid(3)
    fcircd = 0.0
    lid = 0.0
! EXECUTION
    DO ii=1,n_vort
! L=rho*V*gamma*l
      CALL CROSS_D(vlocal(:, ii), vlocald(:, ii), si(:, ii), sid(:, ii)&
&            , li, lid)
      fcircd(:, ii) = rho*(gamad(ii)*li+gama(ii)*lid)
      fcirc(:, ii) = rho*gama(ii)*li
    END DO
  END SUBROUTINE COMPUTE_CIRCULATION_FORCES_D

!============================================================
  SUBROUTINE COMPUTE_CIRCULATION_FORCES(n_vort, rho, vlocal, si, gama, &
&   fcirc)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: rho, vlocal(3, n_vort), si(3, n_vort)
    REAL, INTENT(IN) :: gama(n_vort)
! Output variables
    REAL, INTENT(OUT) :: fcirc(3, n_vort)
! Working variables
    INTEGER :: ii
    REAL :: li(3)
! EXECUTION
    DO ii=1,n_vort
! L=rho*V*gamma*l
      CALL CROSS(vlocal(:, ii), si(:, ii), li)
      fcirc(:, ii) = rho*gama(ii)*li
    END DO
  END SUBROUTINE COMPUTE_CIRCULATION_FORCES

!  Differentiation of compute_airfoil_forces in forward (tangent) mode:
!   variations   of useful results: fairf
!   with respect to varying inputs: vlocal si areas alphalocal
!============================================================
  SUBROUTINE COMPUTE_AIRFOIL_FORCES_D(n_vort, rho, cl0, cla, areas, &
&   areasd, vlocal, vlocald, alphalocal, alphalocald, si, sid, fairf, &
&   fairfd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: rho, cl0(n_vort), cla(n_vort), areas(n_vort)
    REAL, INTENT(IN) :: areasd(n_vort)
    REAL, INTENT(IN) :: vlocal(3, n_vort), alphalocal(n_vort), si(3, &
&   n_vort)
    REAL, INTENT(IN) :: vlocald(3, n_vort), alphalocald(n_vort), sid(3, &
&   n_vort)
! Output variables
    REAL, INTENT(OUT) :: fairf(3, n_vort)
    REAL, INTENT(OUT) :: fairfd(3, n_vort)
! Working variables
    REAL :: fairfm, cl, li(3), uli(3), vlocalm
    REAL :: fairfmd, cld, lid(3), ulid(3), vlocalmd
    INTEGER :: ii
    fairfd = 0.0
    lid = 0.0
! EXECUTION
! Loop over all horseshoe vortices
    DO ii=1,n_vort
! Compute the magnitude of the force given by the 2D section
! L = 0.5*Vlocal²*area*cl
      cld = cla(ii)*alphalocald(ii)
      cl = cl0(ii) + alphalocal(ii)*cla(ii)
      CALL NORM_D(vlocal(:, ii), vlocald(:, ii), vlocalm, vlocalmd)
      fairfmd = 0.5*rho*((vlocalmd*vlocalm+vlocalm*vlocalmd)*areas(ii)*&
&       cl+vlocalm**2*(areasd(ii)*cl+areas(ii)*cld))
      fairfm = 0.5*rho*vlocalm*vlocalm*areas(ii)*cl
! Get normalized lift direction
      CALL CROSS_D(vlocal(:, ii), vlocald(:, ii), si(:, ii), sid(:, ii)&
&            , li, lid)
      CALL NORMALIZE_D(li, lid, uli, ulid)
! Store the force
      fairfd(:, ii) = fairfmd*uli + fairfm*ulid
      fairf(:, ii) = fairfm*uli
    END DO
  END SUBROUTINE COMPUTE_AIRFOIL_FORCES_D

!============================================================
  SUBROUTINE COMPUTE_AIRFOIL_FORCES(n_vort, rho, cl0, cla, areas, vlocal&
&   , alphalocal, si, fairf)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: rho, cl0(n_vort), cla(n_vort), areas(n_vort)
    REAL, INTENT(IN) :: vlocal(3, n_vort), alphalocal(n_vort), si(3, &
&   n_vort)
! Output variables
    REAL, INTENT(OUT) :: fairf(3, n_vort)
! Working variables
    REAL :: fairfm, cl, li(3), uli(3), vlocalm
    INTEGER :: ii
! EXECUTION
! Loop over all horseshoe vortices
    DO ii=1,n_vort
! Compute the magnitude of the force given by the 2D section
! L = 0.5*Vlocal²*area*cl
      cl = cl0(ii) + alphalocal(ii)*cla(ii)
      CALL NORM(vlocal(:, ii), vlocalm)
      fairfm = 0.5*rho*vlocalm*vlocalm*areas(ii)*cl
! Get normalized lift direction
      CALL CROSS(vlocal(:, ii), si(:, ii), li)
      CALL NORMALIZE(li, uli)
! Store the force
      fairf(:, ii) = fairfm*uli
    END DO
  END SUBROUTINE COMPUTE_AIRFOIL_FORCES

!  Differentiation of get_residuals in forward (tangent) mode:
!   variations   of useful results: res
!   with respect to varying inputs: chords alpha0 x gama
!============================================================
  SUBROUTINE GET_RESIDUALS_D(n_vort, x, xd, gama, gamad, alpha0, alpha0d&
&   , chords, chordsd, cl0, cla, vinf, rho, res, resd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL, INTENT(IN) :: xd(3, n_vort+1)
    REAL, INTENT(IN) :: gama(n_vort), alpha0(n_vort)
    REAL, INTENT(IN) :: gamad(n_vort), alpha0d(n_vort)
    REAL, INTENT(IN) :: chords(n_vort), cl0(n_vort)
    REAL, INTENT(IN) :: chordsd(n_vort)
    REAL, INTENT(IN) :: cla(n_vort), vinf(3), rho
! Output variables
    REAL, INTENT(OUT) :: res(n_vort)
    REAL, INTENT(OUT) :: resd(n_vort)
! Working variables
    INTEGER :: ii
    REAL :: uinf(3), aic(3, n_vort, n_vort)
    REAL :: aicd(3, n_vort, n_vort)
    REAL :: uai(3, n_vort), uni(3, n_vort), si(3, n_vort)
    REAL :: uaid(3, n_vort), unid(3, n_vort), sid(3, n_vort)
    REAL :: areas(n_vort), vlocal(3, n_vort), alphalocal(n_vort)
    REAL :: areasd(n_vort), vlocald(3, n_vort), alphalocald(n_vort)
    REAL :: fcirc(3, n_vort), fairf(3, n_vort), deltaf(3)
    REAL :: fcircd(3, n_vort), fairfd(3, n_vort), deltafd(3)
    INTRINSIC SUM
    REAL, DIMENSION(3) :: arg1
    REAL, DIMENSION(3) :: arg1d
! EXECUTION
! Normalize free-stream velocity
    CALL NORMALIZE(vinf, uinf)
! Get AIC matrix
    CALL GET_AIC_MATRIX_D(n_vort, x, xd, uinf, aic, aicd)
! Get geometric vectors
    CALL GET_GEOM_VECTORS_D(n_vort, x, xd, alpha0, alpha0d, chords, &
&                     chordsd, uai, uaid, uni, unid, si, sid, areas, &
&                     areasd)
! Get induced velocities
    CALL GET_LOCAL_VELS_D(n_vort, gama, gamad, aic, aicd, vinf, uai, &
&                   uaid, uni, unid, vlocal, vlocald, alphalocal, &
&                   alphalocald)
! Get circulation forces
    CALL COMPUTE_CIRCULATION_FORCES_D(n_vort, rho, vlocal, vlocald, si, &
&                               sid, gama, gamad, fcirc, fcircd)
! Get airfoil forces
    CALL COMPUTE_AIRFOIL_FORCES_D(n_vort, rho, cl0, cla, areas, areasd, &
&                           vlocal, vlocald, alphalocal, alphalocald, si&
&                           , sid, fairf, fairfd)
    resd = 0.0
! The residual is the difference between the forces for each horseshoe vortex
    DO ii=1,n_vort
! Get the difference in forces
      deltafd = fcircd(:, ii) - fairfd(:, ii)
      deltaf = fcirc(:, ii) - fairf(:, ii)
! The residual is the magnitude of the difference
      arg1d(:) = 2*deltaf*deltafd
      arg1(:) = deltaf**2
      resd(ii) = SUM(arg1d(:))
      res(ii) = SUM(arg1(:))
    END DO
  END SUBROUTINE GET_RESIDUALS_D

!============================================================
  SUBROUTINE GET_RESIDUALS(n_vort, x, gama, alpha0, chords, cl0, cla, &
&   vinf, rho, res)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL, INTENT(IN) :: gama(n_vort), alpha0(n_vort)
    REAL, INTENT(IN) :: chords(n_vort), cl0(n_vort)
    REAL, INTENT(IN) :: cla(n_vort), vinf(3), rho
! Output variables
    REAL, INTENT(OUT) :: res(n_vort)
! Working variables
    INTEGER :: ii
    REAL :: uinf(3), aic(3, n_vort, n_vort)
    REAL :: uai(3, n_vort), uni(3, n_vort), si(3, n_vort)
    REAL :: areas(n_vort), vlocal(3, n_vort), alphalocal(n_vort)
    REAL :: fcirc(3, n_vort), fairf(3, n_vort), deltaf(3)
    INTRINSIC SUM
    REAL, DIMENSION(3) :: arg1
! EXECUTION
! Normalize free-stream velocity
    CALL NORMALIZE(vinf, uinf)
! Get AIC matrix
    CALL GET_AIC_MATRIX(n_vort, x, uinf, aic)
! Get geometric vectors
    CALL GET_GEOM_VECTORS(n_vort, x, alpha0, chords, uai, uni, si, areas&
&                  )
! Get induced velocities
    CALL GET_LOCAL_VELS(n_vort, gama, aic, vinf, uai, uni, vlocal, &
&                 alphalocal)
! Get circulation forces
    CALL COMPUTE_CIRCULATION_FORCES(n_vort, rho, vlocal, si, gama, fcirc&
&                            )
! Get airfoil forces
    CALL COMPUTE_AIRFOIL_FORCES(n_vort, rho, cl0, cla, areas, vlocal, &
&                         alphalocal, si, fairf)
! The residual is the difference between the forces for each horseshoe vortex
    DO ii=1,n_vort
! Get the difference in forces
      deltaf = fcirc(:, ii) - fairf(:, ii)
! The residual is the magnitude of the difference
      arg1(:) = deltaf**2
      res(ii) = SUM(arg1(:))
    END DO
  END SUBROUTINE GET_RESIDUALS

!  Differentiation of get_functions in forward (tangent) mode:
!   variations   of useful results: d l sref cd cl
!   with respect to varying inputs: chords alpha0 x gama
!============================================================
  SUBROUTINE GET_FUNCTIONS_D(n_vort, x, xd, gama, gamad, alpha0, alpha0d&
&   , chords, chordsd, cl0, cla, vinf, rho, sref, srefd, cl, cld, cd, &
&   cdd, l, ld, d, dd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL, INTENT(IN) :: xd(3, n_vort+1)
    REAL, INTENT(IN) :: gama(n_vort), alpha0(n_vort)
    REAL, INTENT(IN) :: gamad(n_vort), alpha0d(n_vort)
    REAL, INTENT(IN) :: chords(n_vort), cl0(n_vort)
    REAL, INTENT(IN) :: chordsd(n_vort)
    REAL, INTENT(IN) :: cla(n_vort), vinf(3), rho
! Output variables
    REAL, INTENT(OUT) :: sref, cl, cd, l, d
    REAL, INTENT(OUT) :: srefd, cld, cdd, ld, dd
! Working variables
    REAL :: uinf(3), aic(3, n_vort, n_vort)
    REAL :: uinfd(3), aicd(3, n_vort, n_vort)
    REAL :: uai(3, n_vort), uni(3, n_vort), si(3, n_vort)
    REAL :: uaid(3, n_vort), unid(3, n_vort), sid(3, n_vort)
    REAL :: areas(n_vort), vlocal(3, n_vort), alphalocal(n_vort)
    REAL :: areasd(n_vort), vlocald(3, n_vort), alphalocald(n_vort)
    REAL :: fcirc(3, n_vort), fbody(3), fbodym, vinfm
    REAL :: fcircd(3, n_vort), fbodyd(3), fbodymd
    INTRINSIC SUM
    INTRINSIC SQRT
    REAL :: arg1
    REAL :: arg1d
! EXECUTION
! Normalize free-stream velocity
    CALL NORMALIZE(vinf, uinf)
! Get AIC matrix
    CALL GET_AIC_MATRIX_D(n_vort, x, xd, uinf, aic, aicd)
! Get geometric vectors
    CALL GET_GEOM_VECTORS_D(n_vort, x, xd, alpha0, alpha0d, chords, &
&                     chordsd, uai, uaid, uni, unid, si, sid, areas, &
&                     areasd)
! Get induced velocities
    unid = 0.0
    uaid = 0.0
    CALL GET_LOCAL_VELS_D(n_vort, gama, gamad, aic, aicd, vinf, uai, &
&                   uaid, uni, unid, vlocal, vlocald, alphalocal, &
&                   alphalocald)
! Get forces on every bound vortex
    CALL COMPUTE_CIRCULATION_FORCES_D(n_vort, rho, vlocal, vlocald, si, &
&                               sid, gama, gamad, fcirc, fcircd)
! Get total force in the system of coordinates of the body
    fbodyd = 0.0
    fbodyd(1) = SUM(fcircd(1, :))
    fbody(1) = SUM(fcirc(1, :))
    fbodyd(2) = SUM(fcircd(2, :))
    fbody(2) = SUM(fcirc(2, :))
    fbodyd(3) = SUM(fcircd(3, :))
    fbody(3) = SUM(fcirc(3, :))
! The drag is aligned with the free-stream
    uinfd = 0.0
    CALL DOT_D(fbody, fbodyd, uinf, uinfd, d, dd)
! The rest is the lift force
    CALL NORM_D(fbody, fbodyd, fbodym, fbodymd)
    arg1d = fbodymd*fbodym + fbodym*fbodymd - dd*d - d*dd
    arg1 = fbodym*fbodym - d*d
    IF (arg1 .EQ. 0.0) THEN
      ld = 0.0
    ELSE
      ld = arg1d/(2.0*SQRT(arg1))
    END IF
    l = SQRT(arg1)
! Use the total area as reference
    srefd = SUM(areasd)
    sref = SUM(areas)
! Make results non dimensional
    CALL NORM(vinf, vinfm)
    cld = (2.0*ld*sref-2.0*l*srefd)/sref**2/vinfm/vinfm/rho
    cl = 2.0*l/sref/vinfm/vinfm/rho
    cdd = (2.0*dd*sref-2.0*d*srefd)/sref**2/vinfm/vinfm/rho
    cd = 2.0*d/sref/vinfm/vinfm/rho
  END SUBROUTINE GET_FUNCTIONS_D

!============================================================
  SUBROUTINE GET_FUNCTIONS(n_vort, x, gama, alpha0, chords, cl0, cla, &
&   vinf, rho, sref, cl, cd, l, d)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL, INTENT(IN) :: gama(n_vort), alpha0(n_vort)
    REAL, INTENT(IN) :: chords(n_vort), cl0(n_vort)
    REAL, INTENT(IN) :: cla(n_vort), vinf(3), rho
! Output variables
    REAL, INTENT(OUT) :: sref, cl, cd, l, d
! Working variables
    REAL :: uinf(3), aic(3, n_vort, n_vort)
    REAL :: uai(3, n_vort), uni(3, n_vort), si(3, n_vort)
    REAL :: areas(n_vort), vlocal(3, n_vort), alphalocal(n_vort)
    REAL :: fcirc(3, n_vort), fbody(3), fbodym, vinfm
    INTRINSIC SUM
    INTRINSIC SQRT
    REAL :: arg1
! EXECUTION
! Normalize free-stream velocity
    CALL NORMALIZE(vinf, uinf)
! Get AIC matrix
    CALL GET_AIC_MATRIX(n_vort, x, uinf, aic)
! Get geometric vectors
    CALL GET_GEOM_VECTORS(n_vort, x, alpha0, chords, uai, uni, si, areas&
&                  )
! Get induced velocities
    CALL GET_LOCAL_VELS(n_vort, gama, aic, vinf, uai, uni, vlocal, &
&                 alphalocal)
! Get forces on every bound vortex
    CALL COMPUTE_CIRCULATION_FORCES(n_vort, rho, vlocal, si, gama, fcirc&
&                            )
! Get total force in the system of coordinates of the body
    fbody(1) = SUM(fcirc(1, :))
    fbody(2) = SUM(fcirc(2, :))
    fbody(3) = SUM(fcirc(3, :))
! The drag is aligned with the free-stream
    CALL DOT(fbody, uinf, d)
! The rest is the lift force
    CALL NORM(fbody, fbodym)
    arg1 = fbodym*fbodym - d*d
    l = SQRT(arg1)
! Use the total area as reference
    sref = SUM(areas)
! Make results non dimensional
    CALL NORM(vinf, vinfm)
    cl = 2.0*l/sref/vinfm/vinfm/rho
    cd = 2.0*d/sref/vinfm/vinfm/rho
  END SUBROUTINE GET_FUNCTIONS

!  Differentiation of norm in forward (tangent) mode:
!   variations   of useful results: am
!   with respect to varying inputs: a
!============================================================
  SUBROUTINE NORM_D(a, ad, am, amd)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3)
    REAL, INTENT(IN) :: ad(3)
    REAL, INTENT(OUT) :: am
    REAL, INTENT(OUT) :: amd
    INTRINSIC SQRT
    REAL :: arg1
    REAL :: arg1d
    arg1d = ad(1)*a(1) + a(1)*ad(1) + ad(2)*a(2) + a(2)*ad(2) + ad(3)*a(&
&     3) + a(3)*ad(3)
    arg1 = a(1)*a(1) + a(2)*a(2) + a(3)*a(3)
    IF (arg1 .EQ. 0.0) THEN
      amd = 0.0
    ELSE
      amd = arg1d/(2.0*SQRT(arg1))
    END IF
    am = SQRT(arg1)
  END SUBROUTINE NORM_D

!============================================================
  SUBROUTINE NORM(a, am)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3)
    REAL, INTENT(OUT) :: am
    INTRINSIC SQRT
    REAL :: arg1
    arg1 = a(1)*a(1) + a(2)*a(2) + a(3)*a(3)
    am = SQRT(arg1)
  END SUBROUTINE NORM

!  Differentiation of normalize in forward (tangent) mode:
!   variations   of useful results: an
!   with respect to varying inputs: a
!============================================================
  SUBROUTINE NORMALIZE_D(a, ad, an, and)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3)
    REAL, INTENT(IN) :: ad(3)
    REAL, INTENT(OUT) :: an(3)
    REAL, INTENT(OUT) :: and(3)
    REAL :: am
    REAL :: amd
    CALL NORM_D(a, ad, am, amd)
    and = (ad*am-a*amd)/am**2
    an = a/am
  END SUBROUTINE NORMALIZE_D

!============================================================
  SUBROUTINE NORMALIZE(a, an)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3)
    REAL, INTENT(OUT) :: an(3)
    REAL :: am
    CALL NORM(a, am)
    an = a/am
  END SUBROUTINE NORMALIZE

!  Differentiation of dot in forward (tangent) mode:
!   variations   of useful results: adb
!   with respect to varying inputs: a b
!============================================================
  SUBROUTINE DOT_D(a, ad, b, bd, adb, adbd)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3), b(3)
    REAL, INTENT(IN) :: ad(3), bd(3)
    REAL, INTENT(OUT) :: adb
    REAL, INTENT(OUT) :: adbd
    INTRINSIC SUM
    adbd = SUM(ad*b + a*bd)
    adb = SUM(a*b)
  END SUBROUTINE DOT_D

!============================================================
  SUBROUTINE DOT(a, b, adb)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3), b(3)
    REAL, INTENT(OUT) :: adb
    INTRINSIC SUM
    adb = SUM(a*b)
  END SUBROUTINE DOT

!  Differentiation of cross in forward (tangent) mode:
!   variations   of useful results: acb
!   with respect to varying inputs: acb a b
!============================================================
  SUBROUTINE CROSS_D(a, ad, b, bd, acb, acbd)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3), b(3)
    REAL, INTENT(IN) :: ad(3), bd(3)
    REAL, INTENT(OUT) :: acb(3)
    REAL, INTENT(OUT) :: acbd(3)
    acbd(1) = ad(2)*b(3) + a(2)*bd(3) - ad(3)*b(2) - a(3)*bd(2)
    acb(1) = a(2)*b(3) - a(3)*b(2)
    acbd(2) = ad(3)*b(1) + a(3)*bd(1) - ad(1)*b(3) - a(1)*bd(3)
    acb(2) = a(3)*b(1) - a(1)*b(3)
    acbd(3) = ad(1)*b(2) + a(1)*bd(2) - ad(2)*b(1) - a(2)*bd(1)
    acb(3) = a(1)*b(2) - a(2)*b(1)
  END SUBROUTINE CROSS_D

!============================================================
  SUBROUTINE CROSS(a, b, acb)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3), b(3)
    REAL, INTENT(OUT) :: acb(3)
    acb(1) = a(2)*b(3) - a(3)*b(2)
    acb(2) = a(3)*b(1) - a(1)*b(3)
    acb(3) = a(1)*b(2) - a(2)*b(1)
  END SUBROUTINE CROSS

!  Differentiation of tapenade_main in forward (tangent) mode:
!   variations   of useful results: d res l sref cd cl
!   with respect to varying inputs: chords alpha0 x gama
!   RW status of diff variables: d:out res:out chords:in l:out
!                alpha0:in x:in sref:out gama:in cd:out cl:out
!============================================================
  SUBROUTINE TAPENADE_MAIN_D(n_vort, x, xd, gama, gamad, alpha0, alpha0d&
&   , chords, chordsd, cl0, cla, vinf, rho, res, resd, sref, srefd, cl, &
&   cld, cd, cdd, l, ld, d, dd)
    IMPLICIT NONE
! Dummy subroutine to allow differentiation of get_residuals and
! get_functions in a single Tapenade call.
! INPUTS
! n_vort: integer -> Number of horseshoe vortices.
! X: real(3,n_vort+1) -> Coordinates of the kinks of the horseshoe vortices.
! Gama: real(n_vort) -> Circulation intensity of each horseshoe vortex.
! alpha0: real(n_vort) -> Array of local incidence angles.
! chords: real(n_vort) -> Array of local chords.
! cl0: real(n_vort) -> cl0 of each 2D section
! cla: real(n_vort) -> lift curve slope of each 2D section [1/rad]
! Vinf: real(3) -> Free-stream velocity vector
! rho: real -> Air density
! OUTPUTS
!res: real(n_vort) -> Residuals of the LLT method
!Sref: real -> Area of all panels
!CL: real -> Lift coefficient (adimensionalized by Sref)
!CD: real -> Drag coefficient (adimensionalized by Sref)
!L: real -> Lift force
!D: real -> Drag force
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL, INTENT(IN) :: xd(3, n_vort+1)
    REAL, INTENT(IN) :: gama(n_vort), alpha0(n_vort)
    REAL, INTENT(IN) :: gamad(n_vort), alpha0d(n_vort)
    REAL, INTENT(IN) :: chords(n_vort), cl0(n_vort)
    REAL, INTENT(IN) :: chordsd(n_vort)
    REAL, INTENT(IN) :: cla(n_vort), vinf(3), rho
! Output variables
    REAL, INTENT(OUT) :: sref, cl, cd, l, d
    REAL, INTENT(OUT) :: srefd, cld, cdd, ld, dd
    REAL, INTENT(OUT) :: res(n_vort)
    REAL, INTENT(OUT) :: resd(n_vort)
    CALL GET_FUNCTIONS_D(n_vort, x, xd, gama, gamad, alpha0, alpha0d, &
&                  chords, chordsd, cl0, cla, vinf, rho, sref, srefd, cl&
&                  , cld, cd, cdd, l, ld, d, dd)
    CALL GET_RESIDUALS_D(n_vort, x, xd, gama, gamad, alpha0, alpha0d, &
&                  chords, chordsd, cl0, cla, vinf, rho, res, resd)
  END SUBROUTINE TAPENADE_MAIN_D

!============================================================
  SUBROUTINE TAPENADE_MAIN(n_vort, x, gama, alpha0, chords, cl0, cla, &
&   vinf, rho, res, sref, cl, cd, l, d)
    IMPLICIT NONE
! Dummy subroutine to allow differentiation of get_residuals and
! get_functions in a single Tapenade call.
! INPUTS
! n_vort: integer -> Number of horseshoe vortices.
! X: real(3,n_vort+1) -> Coordinates of the kinks of the horseshoe vortices.
! Gama: real(n_vort) -> Circulation intensity of each horseshoe vortex.
! alpha0: real(n_vort) -> Array of local incidence angles.
! chords: real(n_vort) -> Array of local chords.
! cl0: real(n_vort) -> cl0 of each 2D section
! cla: real(n_vort) -> lift curve slope of each 2D section [1/rad]
! Vinf: real(3) -> Free-stream velocity vector
! rho: real -> Air density
! OUTPUTS
!res: real(n_vort) -> Residuals of the LLT method
!Sref: real -> Area of all panels
!CL: real -> Lift coefficient (adimensionalized by Sref)
!CD: real -> Drag coefficient (adimensionalized by Sref)
!L: real -> Lift force
!D: real -> Drag force
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL, INTENT(IN) :: gama(n_vort), alpha0(n_vort)
    REAL, INTENT(IN) :: chords(n_vort), cl0(n_vort)
    REAL, INTENT(IN) :: cla(n_vort), vinf(3), rho
! Output variables
    REAL, INTENT(OUT) :: sref, cl, cd, l, d
    REAL, INTENT(OUT) :: res(n_vort)
    CALL GET_FUNCTIONS(n_vort, x, gama, alpha0, chords, cl0, cla, vinf, &
&                rho, sref, cl, cd, l, d)
    CALL GET_RESIDUALS(n_vort, x, gama, alpha0, chords, cl0, cla, vinf, &
&                rho, res)
  END SUBROUTINE TAPENADE_MAIN

END MODULE LLT_MODULE_DIFF


