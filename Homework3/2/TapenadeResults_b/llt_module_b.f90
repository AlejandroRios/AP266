!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7260) - 18 Jan 2019 10:11
!
MODULE LLT_MODULE_B
  IMPLICIT NONE
  REAL, PARAMETER :: zero=0.0
  REAL, PARAMETER :: pi=3.1415926535897932384626
  REAL, PARAMETER :: eps=EPSILON(zero)

CONTAINS
!  Differentiation of induced_vel in reverse (adjoint) mode:
!   gradient     of useful results: x gamma_ind
!   with respect to varying inputs: x x1 x2
  SUBROUTINE INDUCED_VEL_B(uinf, x1, x1b, x2, x2b, x, xb, gamma_ind, &
&   gamma_indb)
    IMPLICIT NONE
! This subroutine computes the velocity induced by
! a horseshoe vortex with kinks at X1 and X2 at the
! point X.
!
! INPUTS
!
! Uinf: real(3) -> Unitary vector along the free-stream direction
! X1: real(3) -> Coordinates of the first kink of the horseshoe vortex
! X2: real(3) -> Coordinates of the second kink of the horseshoe vortex
! X: real(3) -> Coordinates where we want the induced velocity
!
! OUTPUTS
!
! gamma_ind: real(3) -> Aerodynamic influence vector induced
!                       by the horseshoe vortex
    REAL, INTENT(IN) :: uinf(3), x1(3), x2(3), x(3)
    REAL :: x1b(3), x2b(3), xb(3)
    REAL :: r1v(3), r2v(3), r1vr2vcross(3), r1, r2, uinfr1vcross(3), &
&   uinfr2vcross(3), uinfr2vdot, r1vr2vdot, uinfr1vdot, p1(3), p2(3), p3&
&   (3)
    REAL :: r1vb(3), r2vb(3), r1vr2vcrossb(3), r1b, r2b, uinfr1vcrossb(3&
&   ), uinfr2vcrossb(3), uinfr2vdotb, r1vr2vdotb, uinfr1vdotb, p1b(3), &
&   p2b(3), p3b(3)
    REAL :: gamma_ind(3)
    REAL :: gamma_indb(3)
    REAL, DIMENSION(3) :: tempb
    REAL :: tempb0
    REAL, DIMENSION(3) :: tempb1
    REAL :: tempb2
    REAL :: temp
    REAL :: temp0
    REAL, DIMENSION(3) :: tempb3
    REAL :: tempb4
    REAL :: tempb5
    REAL, DIMENSION(3) :: tempb6
    INTEGER :: branch
    REAL :: uinfb(3)
    r1v = x - x1
    r2v = x - x2
    CALL NORM(r1v, r1)
! Norm of vector r1v
    CALL NORM(r2v, r2)
! Norm of vector r2v
    CALL CROSS(r1v, r2v, r1vr2vcross)
! Cross product of the vectors r1v and r2v
    CALL CROSS(uinf, r1v, uinfr1vcross)
! Cross product of the vectors uinf and r1v
    CALL CROSS(uinf, r2v, uinfr2vcross)
! Cross product of the vectors uinf and r2v
    CALL DOT(uinf, r2v, uinfr2vdot)
! Dot product of the vectors uinf and r2v
    CALL DOT(r1v, r2v, r1vr2vdot)
! Dot product of the vectors r1v and r2v
    CALL DOT(uinf, r1v, uinfr1vdot)
! Dot product of the vectors uinf and r1v
    IF (r1*r2*(r1*r2+r1vr2vdot) .LT. 1e-2) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    p1b = 0.0
    p2b = 0.0
    p3b = 0.0
    tempb6 = gamma_indb/(4*pi)
    p1b = tempb6
    p2b = tempb6
    p3b = -tempb6
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      r1vr2vdotb = 0.0
      r1b = 0.0
      r2b = 0.0
      r1vr2vcrossb = 0.0
    ELSE
      r1vr2vcrossb = 0.0
      temp = r1*r2 + r1vr2vdot
      temp0 = r1*r2*temp
      tempb3 = p2b/temp0
      tempb4 = SUM(-((r1+r2)*r1vr2vcross*tempb3/temp0))
      tempb5 = r1*r2*tempb4
      r1b = r2*tempb5 + temp*r2*tempb4 + SUM(r1vr2vcross*tempb3)
      r2b = r1*tempb5 + temp*r1*tempb4 + SUM(r1vr2vcross*tempb3)
      r1vr2vcrossb = (r1+r2)*tempb3
      r1vr2vdotb = tempb5
    END IF
    uinfr1vcrossb = 0.0
    tempb = p3b/(r1*(r1-uinfr1vdot))
    tempb0 = SUM(-(uinfr1vcross*tempb/(r1*(r1-uinfr1vdot))))
    uinfr1vcrossb = tempb
    r1b = r1b + (2*r1-uinfr1vdot)*tempb0
    uinfr1vdotb = -(r1*tempb0)
    uinfr2vcrossb = 0.0
    tempb1 = p1b/(r2*(r2-uinfr2vdot))
    tempb2 = SUM(-(uinfr2vcross*tempb1/(r2*(r2-uinfr2vdot))))
    uinfr2vcrossb = tempb1
    r2b = r2b + (2*r2-uinfr2vdot)*tempb2
    uinfr2vdotb = -(r2*tempb2)
    uinfb = 0.0
    r1vb = 0.0
    CALL DOT_B(uinf, uinfb, r1v, r1vb, uinfr1vdot, uinfr1vdotb)
    r2vb = 0.0
    CALL DOT_B(r1v, r1vb, r2v, r2vb, r1vr2vdot, r1vr2vdotb)
    uinfb = 0.0
    CALL DOT_B(uinf, uinfb, r2v, r2vb, uinfr2vdot, uinfr2vdotb)
    uinfb = 0.0
    CALL CROSS_B(uinf, uinfb, r2v, r2vb, uinfr2vcross, uinfr2vcrossb)
    uinfb = 0.0
    CALL CROSS_B(uinf, uinfb, r1v, r1vb, uinfr1vcross, uinfr1vcrossb)
    CALL CROSS_B(r1v, r1vb, r2v, r2vb, r1vr2vcross, r1vr2vcrossb)
    CALL NORM_B(r2v, r2vb, r2, r2b)
    CALL NORM_B(r1v, r1vb, r1, r1b)
    x2b = 0.0
    xb = xb + r1vb + r2vb
    x2b = -r2vb
    x1b = 0.0
    x1b = -r1vb
  END SUBROUTINE INDUCED_VEL_B

  SUBROUTINE INDUCED_VEL(uinf, x1, x2, x, gamma_ind)
    IMPLICIT NONE
! This subroutine computes the velocity induced by
! a horseshoe vortex with kinks at X1 and X2 at the
! point X.
!
! INPUTS
!
! Uinf: real(3) -> Unitary vector along the free-stream direction
! X1: real(3) -> Coordinates of the first kink of the horseshoe vortex
! X2: real(3) -> Coordinates of the second kink of the horseshoe vortex
! X: real(3) -> Coordinates where we want the induced velocity
!
! OUTPUTS
!
! gamma_ind: real(3) -> Aerodynamic influence vector induced
!                       by the horseshoe vortex
    REAL, INTENT(IN) :: uinf(3), x1(3), x2(3), x(3)
    REAL :: r1v(3), r2v(3), r1vr2vcross(3), r1, r2, uinfr1vcross(3), &
&   uinfr2vcross(3), uinfr2vdot, r1vr2vdot, uinfr1vdot, p1(3), p2(3), p3&
&   (3)
    REAL, INTENT(OUT) :: gamma_ind(3)
    r1v = x - x1
    r2v = x - x2
    CALL NORM(r1v, r1)
! Norm of vector r1v
    CALL NORM(r2v, r2)
! Norm of vector r2v
    CALL CROSS(r1v, r2v, r1vr2vcross)
! Cross product of the vectors r1v and r2v
    CALL CROSS(uinf, r1v, uinfr1vcross)
! Cross product of the vectors uinf and r1v
    CALL CROSS(uinf, r2v, uinfr2vcross)
! Cross product of the vectors uinf and r2v
    CALL DOT(uinf, r2v, uinfr2vdot)
! Dot product of the vectors uinf and r2v
    CALL DOT(r1v, r2v, r1vr2vdot)
! Dot product of the vectors r1v and r2v
    CALL DOT(uinf, r1v, uinfr1vdot)
! Dot product of the vectors uinf and r1v
    p1 = uinfr2vcross/(r2*(r2-uinfr2vdot))
    p3 = uinfr1vcross/(r1*(r1-uinfr1vdot))
    IF (r1*r2*(r1*r2+r1vr2vdot) .LT. 1e-2) THEN
      p2 = 0
    ELSE
      p2 = (r1+r2)*r1vr2vcross/(r1*r2*(r1*r2+r1vr2vdot))
    END IF
    gamma_ind = 1/(4*pi)*(p1+p2-p3)
  END SUBROUTINE INDUCED_VEL

!  Differentiation of get_aic_matrix in reverse (adjoint) mode:
!   gradient     of useful results: x aic
!   with respect to varying inputs: x
!============================================================
  SUBROUTINE GET_AIC_MATRIX_B(nv, x, xb, uinf, aic, aicb)
    IMPLICIT NONE
! This subroutine computes the Aerodynamic Influence Coefficients (AIC)
! matrix that gives the adimensionalized induced velocities in
! all bound segments in X, that is: Vind = AIC*Gamma.
! Vind(1:3,ii) = AIC(1:3,:,ii)*Gamma(:)
! INPUTS
! n_vort: integer -> Number of horseshoe vortices.
! X: real(3,n_vort+1) -> Coordinates of the kinks of the horseshoe vortices.
! Uinf: real(3) -> Unitary vector along the free-stream direction.
! OUTPUTS
! AIC: real(3,n_vort,n_vort) -> Aerodynamic Influence matrix.
    INTEGER, INTENT(IN) :: nv
    INTEGER :: ii, jj
    REAL :: x1ii(3), x2ii(3), x1jj(3), x2jj(3), xc(3), gamma_ind(3)
    REAL :: x1iib(3), x2iib(3), x1jjb(3), x2jjb(3), xcb(3), gamma_indb(3&
&   )
    REAL, INTENT(IN) :: x(3, nv+1), uinf(3)
    REAL :: xb(3, nv+1)
    REAL :: aic(3, nv, nv)
    REAL :: aicb(3, nv, nv)
    DO ii=1,nv
      x1ii = x(:, ii)
      x2ii = x(:, ii+1)
      CALL PUSHREAL8ARRAY(xc, 3)
      xc = (x1ii+x2ii)/2
    END DO
    DO ii=nv,1,-1
      xcb = 0.0
      DO jj=nv,1,-1
        gamma_indb = 0.0
        gamma_indb = aicb(:, jj, ii)
        aicb(:, jj, ii) = 0.0
        x1jj = x(:, jj)
        x2jj = x(:, jj+1)
        CALL INDUCED_VEL_B(uinf, x1jj, x1jjb, x2jj, x2jjb, xc, xcb, &
&                    gamma_ind, gamma_indb)
        xb(:, jj+1) = xb(:, jj+1) + x2jjb
        xb(:, jj) = xb(:, jj) + x1jjb
      END DO
      x2iib = 0.0
      x1iib = 0.0
      CALL POPREAL8ARRAY(xc, 3)
      x1iib = xcb/2
      x2iib = xcb/2
      xb(:, ii+1) = xb(:, ii+1) + x2iib
      xb(:, ii) = xb(:, ii) + x1iib
    END DO
  END SUBROUTINE GET_AIC_MATRIX_B

!============================================================
  SUBROUTINE GET_AIC_MATRIX(nv, x, uinf, aic)
    IMPLICIT NONE
! This subroutine computes the Aerodynamic Influence Coefficients (AIC)
! matrix that gives the adimensionalized induced velocities in
! all bound segments in X, that is: Vind = AIC*Gamma.
! Vind(1:3,ii) = AIC(1:3,:,ii)*Gamma(:)
! INPUTS
! n_vort: integer -> Number of horseshoe vortices.
! X: real(3,n_vort+1) -> Coordinates of the kinks of the horseshoe vortices.
! Uinf: real(3) -> Unitary vector along the free-stream direction.
! OUTPUTS
! AIC: real(3,n_vort,n_vort) -> Aerodynamic Influence matrix.
    INTEGER, INTENT(IN) :: nv
    INTEGER :: ii, jj
    REAL :: x1ii(3), x2ii(3), x1jj(3), x2jj(3), xc(3), gamma_ind(3)
    REAL, INTENT(IN) :: x(3, nv+1), uinf(3)
    REAL, INTENT(OUT) :: aic(3, nv, nv)
    DO ii=1,nv
      x1ii = x(:, ii)
      x2ii = x(:, ii+1)
      xc = (x1ii+x2ii)/2
      DO jj=1,nv
        x1jj = x(:, jj)
        x2jj = x(:, jj+1)
        CALL INDUCED_VEL(uinf, x1jj, x2jj, xc, gamma_ind)
        aic(:, jj, ii) = gamma_ind
      END DO
    END DO
  END SUBROUTINE GET_AIC_MATRIX

!  Differentiation of get_geom_vectors in reverse (adjoint) mode:
!   gradient     of useful results: chords alpha0 x uai uni si
!                areas
!   with respect to varying inputs: chords alpha0 x
!============================================================
  SUBROUTINE GET_GEOM_VECTORS_B(n_vort, x, xb, alpha0, alpha0b, chords, &
&   chordsb, uai, uaib, uni, unib, si, sib, areas, areasb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL :: xb(3, n_vort+1)
    REAL, INTENT(IN) :: alpha0(n_vort), chords(n_vort)
    REAL :: alpha0b(n_vort), chordsb(n_vort)
! Output variables
    REAL :: uai(3, n_vort), uni(3, n_vort)
    REAL :: uaib(3, n_vort), unib(3, n_vort)
    REAL :: si(3, n_vort), areas(n_vort)
    REAL :: sib(3, n_vort), areasb(n_vort)
! Working variables
    INTEGER :: ii
    REAL :: x1(3), x2(3), usi(3), ni(3)
    REAL :: x1b(3), x2b(3), usib(3), nib(3)
    REAL :: nim, sim
    REAL :: nimb, simb
    INTRINSIC COS
    INTRINSIC SIN
! EXECUTION
! Loop over all vortices
    DO ii=1,n_vort
! Get kink coordinates of the current vortex
      x1 = x(:, ii)
      x2 = x(:, ii+1)
! Compute the vector along the local span
      si(:, ii) = x2 - x1
      CALL PUSHREAL8ARRAY(usi, 3)
      CALL NORMALIZE(si(:, ii), usi)
! Create a unitary vector along the chordline
! pointing to the trailing edge
      uai(1, ii) = COS(alpha0(ii))
      uai(2, ii) = zero
      uai(3, ii) = -SIN(alpha0(ii))
! Get the normal vector as the normal between the span
! and the chord vector
      CALL PUSHREAL8ARRAY(ni, 3)
      CALL CROSS(uai(:, ii), usi, ni)
! Compute the local area of the panel.
! The norm of the normal vector is the sine of the angle.
      CALL PUSHREAL8(nim)
      CALL NORM(ni, nim)
      CALL PUSHREAL8(sim)
      CALL NORM(si(:, ii), sim)
    END DO
    nib = 0.0
    DO ii=n_vort,1,-1
      chordsb(ii) = chordsb(ii) + nim*sim*areasb(ii)
      nimb = chords(ii)*sim*areasb(ii)
      simb = chords(ii)*nim*areasb(ii)
      areasb(ii) = 0.0
      CALL POPREAL8(sim)
      CALL NORM_B(si(:, ii), sib(:, ii), sim, simb)
      CALL POPREAL8(nim)
      CALL NORM_B(ni, nib, nim, nimb)
      CALL NORMALIZE_B(ni, nib, uni(:, ii), unib(:, ii))
      unib(:, ii) = 0.0
      CALL POPREAL8ARRAY(ni, 3)
      usib = 0.0
      CALL CROSS_B(uai(:, ii), uaib(:, ii), usi, usib, ni, nib)
      alpha0b(ii) = alpha0b(ii) - COS(alpha0(ii))*uaib(3, ii)
      uaib(3, ii) = 0.0
      uaib(2, ii) = 0.0
      alpha0b(ii) = alpha0b(ii) - SIN(alpha0(ii))*uaib(1, ii)
      uaib(1, ii) = 0.0
      CALL POPREAL8ARRAY(usi, 3)
      CALL NORMALIZE_B(si(:, ii), sib(:, ii), usi, usib)
      x1b = 0.0
      x2b = 0.0
      x2b = sib(:, ii)
      x1b = -sib(:, ii)
      sib(:, ii) = 0.0
      xb(:, ii+1) = xb(:, ii+1) + x2b
      xb(:, ii) = xb(:, ii) + x1b
    END DO
  END SUBROUTINE GET_GEOM_VECTORS_B

!============================================================
  SUBROUTINE GET_GEOM_VECTORS(n_vort, x, alpha0, chords, uai, uni, si, &
&   areas)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL, INTENT(IN) :: alpha0(n_vort), chords(n_vort)
! Output variables
    REAL, INTENT(OUT) :: uai(3, n_vort), uni(3, n_vort)
    REAL, INTENT(OUT) :: si(3, n_vort), areas(n_vort)
! Working variables
    INTEGER :: ii
    REAL :: x1(3), x2(3), usi(3), ni(3)
    REAL :: nim, sim
    INTRINSIC COS
    INTRINSIC SIN
! EXECUTION
! Loop over all vortices
    DO ii=1,n_vort
! Get kink coordinates of the current vortex
      x1 = x(:, ii)
      x2 = x(:, ii+1)
! Compute the vector along the local span
      si(:, ii) = x2 - x1
      CALL NORMALIZE(si(:, ii), usi)
! Create a unitary vector along the chordline
! pointing to the trailing edge
      uai(1, ii) = COS(alpha0(ii))
      uai(2, ii) = zero
      uai(3, ii) = -SIN(alpha0(ii))
! Get the normal vector as the normal between the span
! and the chord vector
      CALL CROSS(uai(:, ii), usi, ni)
      CALL NORMALIZE(ni, uni(:, ii))
! Compute the local area of the panel.
! The norm of the normal vector is the sine of the angle.
      CALL NORM(ni, nim)
      CALL NORM(si(:, ii), sim)
      areas(ii) = nim*chords(ii)*sim
    END DO
  END SUBROUTINE GET_GEOM_VECTORS

!  Differentiation of get_local_vels in reverse (adjoint) mode:
!   gradient     of useful results: vlocal gama alphalocal
!   with respect to varying inputs: uai uni gama aic
!============================================================
  SUBROUTINE GET_LOCAL_VELS_B(n_vort, gama, gamab, aic, aicb, vinf, uai&
&   , uaib, uni, unib, vlocal, vlocalb, alphalocal, alphalocalb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: gama(n_vort), aic(3, n_vort, n_vort)
    REAL :: gamab(n_vort), aicb(3, n_vort, n_vort)
    REAL, INTENT(IN) :: vinf(3), uai(3, n_vort), uni(3, n_vort)
    REAL :: uaib(3, n_vort), unib(3, n_vort)
! Output variables
    REAL :: vlocal(3, n_vort), alphalocal(n_vort)
    REAL :: vlocalb(3, n_vort), alphalocalb(n_vort)
! Working variables
    INTEGER :: ii, jj
    REAL :: num, den
    REAL :: numb, denb
    INTRINSIC ATAN
    REAL :: tempb
! EXECUTION
! Do the matrix operation
    DO ii=1,n_vort
! Start with the free-strem contribution
      vlocal(:, ii) = vinf
! Now add the velocities induced by each vortex
      DO jj=1,n_vort
        vlocal(:, ii) = vlocal(:, ii) + aic(:, jj, ii)*gama(jj)
      END DO
! Compute the local angle of attack
      CALL PUSHREAL8(num)
      CALL DOT(vlocal(:, ii), uni(:, ii), num)
      CALL PUSHREAL8(den)
      CALL DOT(vlocal(:, ii), uai(:, ii), den)
    END DO
    uaib = 0.0
    unib = 0.0
    aicb = 0.0
    DO ii=n_vort,1,-1
      tempb = alphalocalb(ii)/((1.0+(num/den)**2)*den)
      numb = tempb
      denb = -(num*tempb/den)
      alphalocalb(ii) = 0.0
      CALL POPREAL8(den)
      CALL DOT_B(vlocal(:, ii), vlocalb(:, ii), uai(:, ii), uaib(:, ii)&
&          , den, denb)
      CALL POPREAL8(num)
      CALL DOT_B(vlocal(:, ii), vlocalb(:, ii), uni(:, ii), unib(:, ii)&
&          , num, numb)
      DO jj=n_vort,1,-1
        aicb(:, jj, ii) = aicb(:, jj, ii) + gama(jj)*vlocalb(:, ii)
        gamab(jj) = gamab(jj) + SUM(aic(:, jj, ii)*vlocalb(:, ii))
      END DO
      vlocalb(:, ii) = 0.0
    END DO
  END SUBROUTINE GET_LOCAL_VELS_B

!============================================================
  SUBROUTINE GET_LOCAL_VELS(n_vort, gama, aic, vinf, uai, uni, vlocal, &
&   alphalocal)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: gama(n_vort), aic(3, n_vort, n_vort)
    REAL, INTENT(IN) :: vinf(3), uai(3, n_vort), uni(3, n_vort)
! Output variables
    REAL, INTENT(OUT) :: vlocal(3, n_vort), alphalocal(n_vort)
! Working variables
    INTEGER :: ii, jj
    REAL :: num, den
    INTRINSIC ATAN
! EXECUTION
! Do the matrix operation
    DO ii=1,n_vort
! Start with the free-strem contribution
      vlocal(:, ii) = vinf
! Now add the velocities induced by each vortex
      DO jj=1,n_vort
        vlocal(:, ii) = vlocal(:, ii) + aic(:, jj, ii)*gama(jj)
      END DO
! Compute the local angle of attack
      CALL DOT(vlocal(:, ii), uni(:, ii), num)
      CALL DOT(vlocal(:, ii), uai(:, ii), den)
      alphalocal(ii) = ATAN(num/den)
    END DO
  END SUBROUTINE GET_LOCAL_VELS

!  Differentiation of compute_circulation_forces in reverse (adjoint) mode:
!   gradient     of useful results: vlocal gama si fcirc
!   with respect to varying inputs: vlocal gama si
!============================================================
  SUBROUTINE COMPUTE_CIRCULATION_FORCES_B(n_vort, rho, vlocal, vlocalb, &
&   si, sib, gama, gamab, fcirc, fcircb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: rho, vlocal(3, n_vort), si(3, n_vort)
    REAL :: vlocalb(3, n_vort), sib(3, n_vort)
    REAL, INTENT(IN) :: gama(n_vort)
    REAL :: gamab(n_vort)
! Output variables
    REAL :: fcirc(3, n_vort)
    REAL :: fcircb(3, n_vort)
! Working variables
    INTEGER :: ii
    REAL :: li(3)
    REAL :: lib(3)
! EXECUTION
    DO ii=1,n_vort
! L=rho*V*gamma*l
      CALL PUSHREAL8ARRAY(li, 3)
      CALL CROSS(vlocal(:, ii), si(:, ii), li)
    END DO
    lib = 0.0
    DO ii=n_vort,1,-1
      gamab(ii) = gamab(ii) + rho*SUM(li*fcircb(:, ii))
      lib = lib + rho*gama(ii)*fcircb(:, ii)
      fcircb(:, ii) = 0.0
      CALL POPREAL8ARRAY(li, 3)
      CALL CROSS_B(vlocal(:, ii), vlocalb(:, ii), si(:, ii), sib(:, ii)&
&            , li, lib)
    END DO
  END SUBROUTINE COMPUTE_CIRCULATION_FORCES_B

!============================================================
  SUBROUTINE COMPUTE_CIRCULATION_FORCES(n_vort, rho, vlocal, si, gama, &
&   fcirc)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: rho, vlocal(3, n_vort), si(3, n_vort)
    REAL, INTENT(IN) :: gama(n_vort)
! Output variables
    REAL, INTENT(OUT) :: fcirc(3, n_vort)
! Working variables
    INTEGER :: ii
    REAL :: li(3)
! EXECUTION
    DO ii=1,n_vort
! L=rho*V*gamma*l
      CALL CROSS(vlocal(:, ii), si(:, ii), li)
      fcirc(:, ii) = rho*gama(ii)*li
    END DO
  END SUBROUTINE COMPUTE_CIRCULATION_FORCES

!  Differentiation of compute_airfoil_forces in reverse (adjoint) mode:
!   gradient     of useful results: fairf
!   with respect to varying inputs: vlocal si areas alphalocal
!============================================================
  SUBROUTINE COMPUTE_AIRFOIL_FORCES_B(n_vort, rho, cl0, cla, areas, &
&   areasb, vlocal, vlocalb, alphalocal, alphalocalb, si, sib, fairf, &
&   fairfb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: rho, cl0(n_vort), cla(n_vort), areas(n_vort)
    REAL :: areasb(n_vort)
    REAL, INTENT(IN) :: vlocal(3, n_vort), alphalocal(n_vort), si(3, &
&   n_vort)
    REAL :: vlocalb(3, n_vort), alphalocalb(n_vort), sib(3, n_vort)
! Output variables
    REAL :: fairf(3, n_vort)
    REAL :: fairfb(3, n_vort)
! Working variables
    REAL :: fairfm, cl, li(3), uli(3), vlocalm
    REAL :: fairfmb, clb, lib(3), ulib(3), vlocalmb
    INTEGER :: ii
    REAL :: tempb
    REAL :: tempb0
! EXECUTION
! Loop over all horseshoe vortices
    DO ii=1,n_vort
! Compute the magnitude of the force given by the 2D section
! L = 0.5*Vlocal²*area*cl
      CALL PUSHREAL8(vlocalm)
      CALL NORM(vlocal(:, ii), vlocalm)
! Get normalized lift direction
      CALL PUSHREAL8ARRAY(li, 3)
      CALL CROSS(vlocal(:, ii), si(:, ii), li)
      CALL PUSHREAL8ARRAY(uli, 3)
      CALL NORMALIZE(li, uli)
! Store the force
    END DO
    vlocalb = 0.0
    sib = 0.0
    areasb = 0.0
    alphalocalb = 0.0
    lib = 0.0
    DO ii=n_vort,1,-1
      cl = cl0(ii) + alphalocal(ii)*cla(ii)
      fairfm = 0.5*rho*vlocalm*vlocalm*areas(ii)*cl
      ulib = 0.0
      fairfmb = SUM(uli*fairfb(:, ii))
      ulib = fairfm*fairfb(:, ii)
      fairfb(:, ii) = 0.0
      CALL POPREAL8ARRAY(uli, 3)
      CALL NORMALIZE_B(li, lib, uli, ulib)
      CALL POPREAL8ARRAY(li, 3)
      CALL CROSS_B(vlocal(:, ii), vlocalb(:, ii), si(:, ii), sib(:, ii)&
&            , li, lib)
      tempb = rho*0.5*fairfmb
      tempb0 = vlocalm**2*tempb
      vlocalmb = areas(ii)*cl*2*vlocalm*tempb
      areasb(ii) = areasb(ii) + cl*tempb0
      clb = areas(ii)*tempb0
      CALL POPREAL8(vlocalm)
      CALL NORM_B(vlocal(:, ii), vlocalb(:, ii), vlocalm, vlocalmb)
      alphalocalb(ii) = alphalocalb(ii) + cla(ii)*clb
    END DO
  END SUBROUTINE COMPUTE_AIRFOIL_FORCES_B

!============================================================
  SUBROUTINE COMPUTE_AIRFOIL_FORCES(n_vort, rho, cl0, cla, areas, vlocal&
&   , alphalocal, si, fairf)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: rho, cl0(n_vort), cla(n_vort), areas(n_vort)
    REAL, INTENT(IN) :: vlocal(3, n_vort), alphalocal(n_vort), si(3, &
&   n_vort)
! Output variables
    REAL, INTENT(OUT) :: fairf(3, n_vort)
! Working variables
    REAL :: fairfm, cl, li(3), uli(3), vlocalm
    INTEGER :: ii
! EXECUTION
! Loop over all horseshoe vortices
    DO ii=1,n_vort
! Compute the magnitude of the force given by the 2D section
! L = 0.5*Vlocal²*area*cl
      cl = cl0(ii) + alphalocal(ii)*cla(ii)
      CALL NORM(vlocal(:, ii), vlocalm)
      fairfm = 0.5*rho*vlocalm*vlocalm*areas(ii)*cl
! Get normalized lift direction
      CALL CROSS(vlocal(:, ii), si(:, ii), li)
      CALL NORMALIZE(li, uli)
! Store the force
      fairf(:, ii) = fairfm*uli
    END DO
  END SUBROUTINE COMPUTE_AIRFOIL_FORCES

!  Differentiation of get_residuals in reverse (adjoint) mode:
!   gradient     of useful results: res
!   with respect to varying inputs: res chords alpha0 x gama
!============================================================
  SUBROUTINE GET_RESIDUALS_B(n_vort, x, xb, gama, gamab, alpha0, alpha0b&
&   , chords, chordsb, cl0, cla, vinf, rho, res, resb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL :: xb(3, n_vort+1)
    REAL, INTENT(IN) :: gama(n_vort), alpha0(n_vort)
    REAL :: gamab(n_vort), alpha0b(n_vort)
    REAL, INTENT(IN) :: chords(n_vort), cl0(n_vort)
    REAL :: chordsb(n_vort)
    REAL, INTENT(IN) :: cla(n_vort), vinf(3), rho
! Output variables
    REAL :: res(n_vort)
    REAL :: resb(n_vort)
! Working variables
    INTEGER :: ii
    REAL :: uinf(3), aic(3, n_vort, n_vort)
    REAL :: aicb(3, n_vort, n_vort)
    REAL :: uai(3, n_vort), uni(3, n_vort), si(3, n_vort)
    REAL :: uaib(3, n_vort), unib(3, n_vort), sib(3, n_vort)
    REAL :: areas(n_vort), vlocal(3, n_vort), alphalocal(n_vort)
    REAL :: areasb(n_vort), vlocalb(3, n_vort), alphalocalb(n_vort)
    REAL :: fcirc(3, n_vort), fairf(3, n_vort), deltaf(3)
    REAL :: fcircb(3, n_vort), fairfb(3, n_vort), deltafb(3)
    INTRINSIC SUM
! EXECUTION
! Normalize free-stream velocity
    CALL NORMALIZE(vinf, uinf)
! Get AIC matrix
    CALL GET_AIC_MATRIX(n_vort, x, uinf, aic)
! Get geometric vectors
    CALL PUSHREAL8ARRAY(uai, 3*n_vort)
    CALL GET_GEOM_VECTORS(n_vort, x, alpha0, chords, uai, uni, si, areas&
&                  )
! Get induced velocities
    CALL GET_LOCAL_VELS(n_vort, gama, aic, vinf, uai, uni, vlocal, &
&                 alphalocal)
! Get circulation forces
    CALL COMPUTE_CIRCULATION_FORCES(n_vort, rho, vlocal, si, gama, fcirc&
&                            )
! Get airfoil forces
    CALL COMPUTE_AIRFOIL_FORCES(n_vort, rho, cl0, cla, areas, vlocal, &
&                         alphalocal, si, fairf)
    fairfb = 0.0
    fcircb = 0.0
    DO ii=n_vort,1,-1
      deltaf = fcirc(:, ii) - fairf(:, ii)
      deltafb = 0.0
      deltafb = 2*deltaf*resb(ii)
      resb(ii) = 0.0
      fcircb(:, ii) = fcircb(:, ii) + deltafb
      fairfb(:, ii) = fairfb(:, ii) - deltafb
    END DO
    CALL COMPUTE_AIRFOIL_FORCES_B(n_vort, rho, cl0, cla, areas, areasb, &
&                           vlocal, vlocalb, alphalocal, alphalocalb, si&
&                           , sib, fairf, fairfb)
    gamab = 0.0
    CALL COMPUTE_CIRCULATION_FORCES_B(n_vort, rho, vlocal, vlocalb, si, &
&                               sib, gama, gamab, fcirc, fcircb)
    CALL GET_LOCAL_VELS_B(n_vort, gama, gamab, aic, aicb, vinf, uai, &
&                   uaib, uni, unib, vlocal, vlocalb, alphalocal, &
&                   alphalocalb)
    CALL POPREAL8ARRAY(uai, 3*n_vort)
    xb = 0.0
    alpha0b = 0.0
    chordsb = 0.0
    CALL GET_GEOM_VECTORS_B(n_vort, x, xb, alpha0, alpha0b, chords, &
&                     chordsb, uai, uaib, uni, unib, si, sib, areas, &
&                     areasb)
    CALL GET_AIC_MATRIX_B(n_vort, x, xb, uinf, aic, aicb)
  END SUBROUTINE GET_RESIDUALS_B

!============================================================
  SUBROUTINE GET_RESIDUALS(n_vort, x, gama, alpha0, chords, cl0, cla, &
&   vinf, rho, res)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL, INTENT(IN) :: gama(n_vort), alpha0(n_vort)
    REAL, INTENT(IN) :: chords(n_vort), cl0(n_vort)
    REAL, INTENT(IN) :: cla(n_vort), vinf(3), rho
! Output variables
    REAL, INTENT(OUT) :: res(n_vort)
! Working variables
    INTEGER :: ii
    REAL :: uinf(3), aic(3, n_vort, n_vort)
    REAL :: uai(3, n_vort), uni(3, n_vort), si(3, n_vort)
    REAL :: areas(n_vort), vlocal(3, n_vort), alphalocal(n_vort)
    REAL :: fcirc(3, n_vort), fairf(3, n_vort), deltaf(3)
    INTRINSIC SUM
! EXECUTION
! Normalize free-stream velocity
    CALL NORMALIZE(vinf, uinf)
! Get AIC matrix
    CALL GET_AIC_MATRIX(n_vort, x, uinf, aic)
! Get geometric vectors
    CALL GET_GEOM_VECTORS(n_vort, x, alpha0, chords, uai, uni, si, areas&
&                  )
! Get induced velocities
    CALL GET_LOCAL_VELS(n_vort, gama, aic, vinf, uai, uni, vlocal, &
&                 alphalocal)
! Get circulation forces
    CALL COMPUTE_CIRCULATION_FORCES(n_vort, rho, vlocal, si, gama, fcirc&
&                            )
! Get airfoil forces
    CALL COMPUTE_AIRFOIL_FORCES(n_vort, rho, cl0, cla, areas, vlocal, &
&                         alphalocal, si, fairf)
! The residual is the difference between the forces for each horseshoe vortex
    DO ii=1,n_vort
! Get the difference in forces
      deltaf = fcirc(:, ii) - fairf(:, ii)
! The residual is the magnitude of the difference
      res(ii) = SUM(deltaf**2)
    END DO
  END SUBROUTINE GET_RESIDUALS

!  Differentiation of get_functions in reverse (adjoint) mode:
!   gradient     of useful results: d chords l alpha0 x sref gama
!                cd cl
!   with respect to varying inputs: chords alpha0 x gama
!============================================================
  SUBROUTINE GET_FUNCTIONS_B(n_vort, x, xb, gama, gamab, alpha0, alpha0b&
&   , chords, chordsb, cl0, cla, vinf, rho, sref, srefb, cl, clb, cd, &
&   cdb, l, lb, d, db)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL :: xb(3, n_vort+1)
    REAL, INTENT(IN) :: gama(n_vort), alpha0(n_vort)
    REAL :: gamab(n_vort), alpha0b(n_vort)
    REAL, INTENT(IN) :: chords(n_vort), cl0(n_vort)
    REAL :: chordsb(n_vort)
    REAL, INTENT(IN) :: cla(n_vort), vinf(3), rho
! Output variables
    REAL :: sref, cl, cd, l, d
    REAL :: srefb, clb, cdb, lb, db
! Working variables
    REAL :: uinf(3), aic(3, n_vort, n_vort)
    REAL :: uinfb(3), aicb(3, n_vort, n_vort)
    REAL :: uai(3, n_vort), uni(3, n_vort), si(3, n_vort)
    REAL :: uaib(3, n_vort), unib(3, n_vort), sib(3, n_vort)
    REAL :: areas(n_vort), vlocal(3, n_vort), alphalocal(n_vort)
    REAL :: areasb(n_vort), vlocalb(3, n_vort), alphalocalb(n_vort)
    REAL :: fcirc(3, n_vort), fbody(3), fbodym, vinfm
    REAL :: fcircb(3, n_vort), fbodyb(3), fbodymb
    INTRINSIC SUM
    INTRINSIC SQRT
    REAL :: temp
    REAL :: temp0
    REAL :: temp1
    REAL :: temp2
    REAL :: tempb
    REAL :: tempb0
    REAL :: tempb1
! EXECUTION
! Normalize free-stream velocity
    CALL NORMALIZE(vinf, uinf)
! Get AIC matrix
    CALL GET_AIC_MATRIX(n_vort, x, uinf, aic)
! Get geometric vectors
    CALL PUSHREAL8ARRAY(uai, 3*n_vort)
    CALL GET_GEOM_VECTORS(n_vort, x, alpha0, chords, uai, uni, si, areas&
&                  )
! Get induced velocities
    CALL GET_LOCAL_VELS(n_vort, gama, aic, vinf, uai, uni, vlocal, &
&                 alphalocal)
! Get forces on every bound vortex
    CALL COMPUTE_CIRCULATION_FORCES(n_vort, rho, vlocal, si, gama, fcirc&
&                            )
! Get total force in the system of coordinates of the body
    fbody(1) = SUM(fcirc(1, :))
    fbody(2) = SUM(fcirc(2, :))
    fbody(3) = SUM(fcirc(3, :))
! The drag is aligned with the free-stream
    CALL DOT(fbody, uinf, d)
! The rest is the lift force
    CALL NORM(fbody, fbodym)
    l = SQRT(fbodym*fbodym - d*d)
! Use the total area as reference
    sref = SUM(areas)
! Make results non dimensional
    CALL NORM(vinf, vinfm)
    temp = vinfm**2*rho
    temp0 = temp*sref
    tempb1 = 2.0*clb/temp0
    lb = lb + tempb1
    IF (fbodym**2 - d**2 .EQ. 0.0) THEN
      tempb0 = 0.0
    ELSE
      tempb0 = lb/(2.0*SQRT(fbodym**2-d**2))
    END IF
    temp1 = vinfm**2*rho
    temp2 = temp1*sref
    tempb = 2.0*cdb/temp2
    db = db + tempb - 2*d*tempb0
    srefb = srefb - l*temp*tempb1/temp0 - d*temp1*tempb/temp2
    areasb = 0.0
    areasb = srefb
    fbodymb = 2*fbodym*tempb0
    fbodyb = 0.0
    CALL NORM_B(fbody, fbodyb, fbodym, fbodymb)
    uinfb = 0.0
    CALL DOT_B(fbody, fbodyb, uinf, uinfb, d, db)
    fcircb = 0.0
    fcircb(3, :) = fcircb(3, :) + fbodyb(3)
    fbodyb(3) = 0.0
    fcircb(2, :) = fcircb(2, :) + fbodyb(2)
    fbodyb(2) = 0.0
    fcircb(1, :) = fcircb(1, :) + fbodyb(1)
    vlocalb = 0.0
    sib = 0.0
    CALL COMPUTE_CIRCULATION_FORCES_B(n_vort, rho, vlocal, vlocalb, si, &
&                               sib, gama, gamab, fcirc, fcircb)
    alphalocalb = 0.0
    CALL GET_LOCAL_VELS_B(n_vort, gama, gamab, aic, aicb, vinf, uai, &
&                   uaib, uni, unib, vlocal, vlocalb, alphalocal, &
&                   alphalocalb)
    CALL POPREAL8ARRAY(uai, 3*n_vort)
    uaib = 0.0
    unib = 0.0
    CALL GET_GEOM_VECTORS_B(n_vort, x, xb, alpha0, alpha0b, chords, &
&                     chordsb, uai, uaib, uni, unib, si, sib, areas, &
&                     areasb)
    CALL GET_AIC_MATRIX_B(n_vort, x, xb, uinf, aic, aicb)
  END SUBROUTINE GET_FUNCTIONS_B

!============================================================
  SUBROUTINE GET_FUNCTIONS(n_vort, x, gama, alpha0, chords, cl0, cla, &
&   vinf, rho, sref, cl, cd, l, d)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL, INTENT(IN) :: gama(n_vort), alpha0(n_vort)
    REAL, INTENT(IN) :: chords(n_vort), cl0(n_vort)
    REAL, INTENT(IN) :: cla(n_vort), vinf(3), rho
! Output variables
    REAL, INTENT(OUT) :: sref, cl, cd, l, d
! Working variables
    REAL :: uinf(3), aic(3, n_vort, n_vort)
    REAL :: uai(3, n_vort), uni(3, n_vort), si(3, n_vort)
    REAL :: areas(n_vort), vlocal(3, n_vort), alphalocal(n_vort)
    REAL :: fcirc(3, n_vort), fbody(3), fbodym, vinfm
    INTRINSIC SUM
    INTRINSIC SQRT
! EXECUTION
! Normalize free-stream velocity
    CALL NORMALIZE(vinf, uinf)
! Get AIC matrix
    CALL GET_AIC_MATRIX(n_vort, x, uinf, aic)
! Get geometric vectors
    CALL GET_GEOM_VECTORS(n_vort, x, alpha0, chords, uai, uni, si, areas&
&                  )
! Get induced velocities
    CALL GET_LOCAL_VELS(n_vort, gama, aic, vinf, uai, uni, vlocal, &
&                 alphalocal)
! Get forces on every bound vortex
    CALL COMPUTE_CIRCULATION_FORCES(n_vort, rho, vlocal, si, gama, fcirc&
&                            )
! Get total force in the system of coordinates of the body
    fbody(1) = SUM(fcirc(1, :))
    fbody(2) = SUM(fcirc(2, :))
    fbody(3) = SUM(fcirc(3, :))
! The drag is aligned with the free-stream
    CALL DOT(fbody, uinf, d)
! The rest is the lift force
    CALL NORM(fbody, fbodym)
    l = SQRT(fbodym*fbodym - d*d)
! Use the total area as reference
    sref = SUM(areas)
! Make results non dimensional
    CALL NORM(vinf, vinfm)
    cl = 2.0*l/sref/vinfm/vinfm/rho
    cd = 2.0*d/sref/vinfm/vinfm/rho
  END SUBROUTINE GET_FUNCTIONS

!  Differentiation of norm in reverse (adjoint) mode:
!   gradient     of useful results: am a
!   with respect to varying inputs: a
!============================================================
  SUBROUTINE NORM_B(a, ab, am, amb)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3)
    REAL :: ab(3)
    REAL :: am
    REAL :: amb
    INTRINSIC SQRT
    REAL :: tempb
    IF (a(1)**2 + a(2)**2 + a(3)**2 .EQ. 0.0) THEN
      tempb = 0.0
    ELSE
      tempb = amb/(2.0*SQRT(a(1)**2+a(2)**2+a(3)**2))
    END IF
    ab(1) = ab(1) + 2*a(1)*tempb
    ab(2) = ab(2) + 2*a(2)*tempb
    ab(3) = ab(3) + 2*a(3)*tempb
  END SUBROUTINE NORM_B

!============================================================
  SUBROUTINE NORM(a, am)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3)
    REAL, INTENT(OUT) :: am
    INTRINSIC SQRT
    am = SQRT(a(1)*a(1) + a(2)*a(2) + a(3)*a(3))
  END SUBROUTINE NORM

!  Differentiation of normalize in reverse (adjoint) mode:
!   gradient     of useful results: an a
!   with respect to varying inputs: a
!============================================================
  SUBROUTINE NORMALIZE_B(a, ab, an, anb)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3)
    REAL :: ab(3)
    REAL :: an(3)
    REAL :: anb(3)
    REAL :: am
    REAL :: amb
    CALL NORM(a, am)
    ab = ab + anb/am
    amb = SUM(-(a*anb/am))/am
    CALL NORM_B(a, ab, am, amb)
  END SUBROUTINE NORMALIZE_B

!============================================================
  SUBROUTINE NORMALIZE(a, an)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3)
    REAL, INTENT(OUT) :: an(3)
    REAL :: am
    CALL NORM(a, am)
    an = a/am
  END SUBROUTINE NORMALIZE

!  Differentiation of dot in reverse (adjoint) mode:
!   gradient     of useful results: adb a b
!   with respect to varying inputs: a b
!============================================================
  SUBROUTINE DOT_B(a, ab, b, bb, adb, adbb)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3), b(3)
    REAL :: ab(3), bb(3)
    REAL :: adb
    REAL :: adbb
    INTRINSIC SUM
    ab = ab + b*adbb
    bb = bb + a*adbb
  END SUBROUTINE DOT_B

!============================================================
  SUBROUTINE DOT(a, b, adb)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3), b(3)
    REAL, INTENT(OUT) :: adb
    INTRINSIC SUM
    adb = SUM(a*b)
  END SUBROUTINE DOT

!  Differentiation of cross in reverse (adjoint) mode:
!   gradient     of useful results: acb a b
!   with respect to varying inputs: acb a b
!============================================================
  SUBROUTINE CROSS_B(a, ab, b, bb, acb, acbb)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3), b(3)
    REAL :: ab(3), bb(3)
    REAL :: acb(3)
    REAL :: acbb(3)
    ab(1) = ab(1) + b(2)*acbb(3)
    bb(2) = bb(2) + a(1)*acbb(3)
    ab(2) = ab(2) - b(1)*acbb(3)
    bb(1) = bb(1) - a(2)*acbb(3)
    acbb(3) = 0.0
    ab(3) = ab(3) + b(1)*acbb(2)
    bb(1) = bb(1) + a(3)*acbb(2)
    ab(1) = ab(1) - b(3)*acbb(2)
    bb(3) = bb(3) - a(1)*acbb(2)
    acbb(2) = 0.0
    ab(2) = ab(2) + b(3)*acbb(1)
    bb(3) = bb(3) + a(2)*acbb(1)
    ab(3) = ab(3) - b(2)*acbb(1)
    bb(2) = bb(2) - a(3)*acbb(1)
    acbb(1) = 0.0
  END SUBROUTINE CROSS_B

!============================================================
  SUBROUTINE CROSS(a, b, acb)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3), b(3)
    REAL, INTENT(OUT) :: acb(3)
    acb(1) = a(2)*b(3) - a(3)*b(2)
    acb(2) = a(3)*b(1) - a(1)*b(3)
    acb(3) = a(1)*b(2) - a(2)*b(1)
  END SUBROUTINE CROSS

!  Differentiation of tapenade_main in reverse (adjoint) mode:
!   gradient     of useful results: d res l sref cd cl
!   with respect to varying inputs: d res chords l alpha0 x sref
!                gama cd cl
!   RW status of diff variables: d:in-zero res:in-out chords:out
!                l:in-zero alpha0:out x:out sref:in-zero gama:out
!                cd:in-zero cl:in-zero
!============================================================
  SUBROUTINE TAPENADE_MAIN_B(n_vort, x, xb, gama, gamab, alpha0, alpha0b&
&   , chords, chordsb, cl0, cla, vinf, rho, res, resb, sref, srefb, cl, &
&   clb, cd, cdb, l, lb, d, db)
    IMPLICIT NONE
! Dummy subroutine to allow differentiation of get_residuals and
! get_functions in a single Tapenade call.
! INPUTS
! n_vort: integer -> Number of horseshoe vortices.
! X: real(3,n_vort+1) -> Coordinates of the kinks of the horseshoe vortices.
! Gama: real(n_vort) -> Circulation intensity of each horseshoe vortex.
! alpha0: real(n_vort) -> Array of local incidence angles.
! chords: real(n_vort) -> Array of local chords.
! cl0: real(n_vort) -> cl0 of each 2D section
! cla: real(n_vort) -> lift curve slope of each 2D section [1/rad]
! Vinf: real(3) -> Free-stream velocity vector
! rho: real -> Air density
! OUTPUTS
!res: real(n_vort) -> Residuals of the LLT method
!Sref: real -> Area of all panels
!CL: real -> Lift coefficient (adimensionalized by Sref)
!CD: real -> Drag coefficient (adimensionalized by Sref)
!L: real -> Lift force
!D: real -> Drag force
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL :: xb(3, n_vort+1)
    REAL, INTENT(IN) :: gama(n_vort), alpha0(n_vort)
    REAL :: gamab(n_vort), alpha0b(n_vort)
    REAL, INTENT(IN) :: chords(n_vort), cl0(n_vort)
    REAL :: chordsb(n_vort)
    REAL, INTENT(IN) :: cla(n_vort), vinf(3), rho
! Output variables
    REAL :: sref, cl, cd, l, d
    REAL :: srefb, clb, cdb, lb, db
    REAL :: res(n_vort)
    REAL :: resb(n_vort)
    CALL GET_RESIDUALS_B(n_vort, x, xb, gama, gamab, alpha0, alpha0b, &
&                  chords, chordsb, cl0, cla, vinf, rho, res, resb)
    CALL GET_FUNCTIONS_B(n_vort, x, xb, gama, gamab, alpha0, alpha0b, &
&                  chords, chordsb, cl0, cla, vinf, rho, sref, srefb, cl&
&                  , clb, cd, cdb, l, lb, d, db)
    db = 0.0
    lb = 0.0
    srefb = 0.0
    cdb = 0.0
    clb = 0.0
  END SUBROUTINE TAPENADE_MAIN_B

!============================================================
  SUBROUTINE TAPENADE_MAIN(n_vort, x, gama, alpha0, chords, cl0, cla, &
&   vinf, rho, res, sref, cl, cd, l, d)
    IMPLICIT NONE
! Dummy subroutine to allow differentiation of get_residuals and
! get_functions in a single Tapenade call.
! INPUTS
! n_vort: integer -> Number of horseshoe vortices.
! X: real(3,n_vort+1) -> Coordinates of the kinks of the horseshoe vortices.
! Gama: real(n_vort) -> Circulation intensity of each horseshoe vortex.
! alpha0: real(n_vort) -> Array of local incidence angles.
! chords: real(n_vort) -> Array of local chords.
! cl0: real(n_vort) -> cl0 of each 2D section
! cla: real(n_vort) -> lift curve slope of each 2D section [1/rad]
! Vinf: real(3) -> Free-stream velocity vector
! rho: real -> Air density
! OUTPUTS
!res: real(n_vort) -> Residuals of the LLT method
!Sref: real -> Area of all panels
!CL: real -> Lift coefficient (adimensionalized by Sref)
!CD: real -> Drag coefficient (adimensionalized by Sref)
!L: real -> Lift force
!D: real -> Drag force
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL, INTENT(IN) :: gama(n_vort), alpha0(n_vort)
    REAL, INTENT(IN) :: chords(n_vort), cl0(n_vort)
    REAL, INTENT(IN) :: cla(n_vort), vinf(3), rho
! Output variables
    REAL, INTENT(OUT) :: sref, cl, cd, l, d
    REAL, INTENT(OUT) :: res(n_vort)
    CALL GET_FUNCTIONS(n_vort, x, gama, alpha0, chords, cl0, cla, vinf, &
&                rho, sref, cl, cd, l, d)
    CALL GET_RESIDUALS(n_vort, x, gama, alpha0, chords, cl0, cla, vinf, &
&                rho, res)
  END SUBROUTINE TAPENADE_MAIN

END MODULE LLT_MODULE_B

